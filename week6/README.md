# week6の宿題

- 締切：**2020/11/11 23:59**
- 注意：以下の課題について、元から書いてあるもの以外は`include`してはいけません。
- 解けるぶんだけ解いてください。

## 宿題1: ポーカー１
- `main1.c`を改造し、ポーカーの手役の判定プログラムを書いてください。
- 引数として、ポーカーのカードが５枚与えられます。
    - 例えば d2 s3 c5 c4 s4 だと、ダイヤの２、スペードの３、クローバーの５、クローバーの４、スペードの４、を意味します。
    - ジョーカーはありません
- まず、argvからカード情報を読み込むコードを書いてください
- ヒント：
    - `atoi`は、char配列のアドレスが与えられたときに、そこからヌル文字が発生するところまでを数字として読み込みます。なので、`s[] = "abc123"`のときに`atoi(s)`はうまくいきませんが、`atoi(s + 3)`はちゃんと`123`になります。


### 実行コマンドと想定出力
```bash
$ gcc main1.c -o main1
$ ./main1 d2 s3 c5 c4 s4
[d 2] [s 3] [c 5] [c 4] [s 4]     <- 宿題1ではこの出力の一行目しかチェックしません
[d 2] [s 3] [c 5] [c 4] [s 4] 
My hand: Not sure
```

## 宿題2: ポーカー２
- `main1.c`を引き続き改造し、手札をソートしてください。
- ソートの順番は「クラブ、ダイア、ハート、スペード」（アルファベット順）で、各色の中では1, 2, 3, ..., 13のように低い順に並べてください
- ヒント：
    - 先週のバブルソートを改造して使いましょう
    - 先週のバブルソートでは「要素の比較」に数字の大小や文字列長の大小を使いました。今回はどうすればいいでしょうか。
- この課題を行うと出力が変わるので宿題1の想定出力を満たさなくなりますが、宿題1の評価では出力の一行目しかチェックしないので、大丈夫です。

### 実行コマンドと想定出力
```bash
$ gcc main1.c -o main1
$ ./main1 d2 s3 c5 c4 s4
[d 2] [s 3] [c 5] [c 4] [s 4]     
[c 4] [c 5] [d 2] [s 3] [s 4]     <- 宿題2ではこの出力の二行目しかチェックしません
My hand: Not sure
```

## 宿題3: ポーカー３
- `main1.c`を引き続き改造し、手役を判定してください。
- `check_hand`関数の中身を書き、判定結果によって出力整数を設定してください。役は下記です。下にいくほど強い役です。[参考](https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%82%AB%E3%83%BC%E3%83%BB%E3%83%8F%E3%83%B3%E3%83%89%E3%81%AE%E4%B8%80%E8%A6%A7)
    - One pair: 同じ数字の組が1組
    - Two pair: 同じ数字の組が2組
    - Tree of a kind: 同じ数字が3枚
    - Straight: 5枚のカードの数字が連番になっている。色は問わない。**13 -> 1の接続は常にOKとします。**　つまり、s12, d13, c1, c2, s3 はOKです。
    - Flush: 5枚のカードの色が同じ。数字は問わない
    - Full house: Two pair + Tree of a kind。例えば s2, d2, s5, d5, c5
    - Four of a kind: 同じ数字が4枚
    - Straight flush: StraightかつFlush
    - Royal straight flush: Straight flushかつ数字が10, 11, 12, 13, 1
- 複数の手役の条件を満たすときは、高い手役にしてください。
- この課題を行うと出力が変わるので宿題2の想定出力を満たさなくなりますが、宿題2の評価では出力の二行目しかチェックしないので、大丈夫です。

### 実行コマンドと想定出力
```bash
$ gcc main1.c -o main1
$ ./main1 d2 s3 c5 c4 s4
[d 2] [s 3] [c 5] [c 4] [s 4]     
[c 4] [c 5] [d 2] [s 3] [s 4]     
My hand: One pair!              <- 宿題3ではこの出力の三行目しかチェックしません

$ ./main1 d2 h10 s10 d2 h2 c3
[h 10] [s 10] [d 2] [h 2] [c 3] 
[c 3] [d 2] [h 2] [h 10] [s 10] 
My hand: Two pair!        

$ ./main1 s13 h13 c13 s8 s2
[s 13] [h 13] [c 13] [s 8] [s 2] 
[c 13] [h 13] [s 2] [s 8] [s 13] 
My hand: Tree of a kind!

$ ./main1 s8 h12 c10 s11 s9
[s 8] [h 12] [c 10] [s 11] [s 9] 
[c 10] [h 12] [s 8] [s 9] [s 11] 
My hand: Straight!

$ ./main1 s8 s3 s1 s11 s9
[s 8] [s 3] [s 1] [s 11] [s 9] 
[s 1] [s 3] [s 8] [s 9] [s 11] 
My hand: Flush!

$ ./main1 d2 c3 s2 s3 h3
[d 2] [c 3] [s 2] [s 3] [h 3] 
[c 3] [d 2] [h 3] [s 2] [s 3] 
My hand: Full house!

$ ./main1 d12 c12 s12 h12 h3
[d 12] [c 12] [s 12] [h 12] [h 3] 
[c 12] [d 12] [h 3] [h 12] [s 12] 
My hand: Four of a kind!

$ ./main1 s3 s5 s4 s6 s7
[s 3] [s 5] [s 4] [s 6] [s 7] 
[s 3] [s 4] [s 5] [s 6] [s 7] 
My hand: Straight flush!

$ ./main1 s11 s10 s12 s1 s13
[s 11] [s 10] [s 12] [s 1] [s 13] 
[s 1] [s 10] [s 11] [s 12] [s 13] 
My hand: Royal straight flush!
```



## 宿題4: 16bit非負整数を、二つの8bit非負整数に分割

- `main2.c`を改造し、`unsigned short`のビット列を二つの`unsigned char`に分割するプログラミを書いてください。
- 引数として、`unsigned short`に収まる範囲の整数が与えられます
- それを上位8ビット、下位8ビットに分割し、`unsigned char`として保持してください。
- 例：
    - 65535が与えられたとする。これは`0b1111111111111111`。なので、255（`0b11111111`）と255を返す。
    - 65280が与えられたとする。これは`0b1111111100000000`。なので255と0を返す。
    - 46187が与えられたとする。これは`0b1011010001101011`。なので180（`0b10110100`）と107（`0b01101011`）を返す。

### 実行コマンドと想定出力
```bash
$ gcc main2.c -o main2
$ ./main2 0
0 0 
$ ./main2 65535
255 255
$ ./main2 65280
255 0 
$ ./main2 255
0 255 
$ ./main2 1
0 1
$ ./main2 46187
180 107 
```
