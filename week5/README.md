# week5の宿題

- 締切：**2020/11/4 23:59**
- 注意：以下の課題について、元から書いてあるもの以外は`include`してはいけません。
- 解けるぶんだけ解いてください。


## 宿題1: 引数の数列のソート
- `main1.c`を改造し、バブルソートプログラムを書いてください。
- 引数として、自然数（0以上の整数）が一個以上与えられます。
- それらを昇順に並び替えてください（バブルソート）。そして、スペース１つを挟んで出力してください。
- バブルソートについては、下記に説明しました。ソートというのは要素の集合を、大きい順や小さい順に並び替えるという手続きです。これについてはアルゴリズムの講義で習うので今は深入りしませんが、バブルソートは最も基本的なソートアルゴリズムです。ググればいくらでもコードが出てくるのですが、自分で書いてみてください。

### 実行コマンドと想定出力
```bash
$ gcc main1.c -o main1
$ ./main1 12 56 34
12 34 56
$ ./main1.c 5 4 3 2 1 0
0 1 2 3 4 5
$ ./main1 8 8 3
3 8 8 
$ ./main1 10 0 10 0
0 0 10 10 
```

### バブルソートとは
- [バブルソート](https://en.wikipedia.org/wiki/Bubble_sort)は次のアルゴリズムです。
- 配列中の隣接要素を比べ、`a[i] > a[i + 1]`ならこの二つをスワップします。
- この処理を、先頭から最後まで行います。これにより、一番大きいものを一番右にもっていけます。
- 次に、同様の処理を再度行います。今度は先頭から最後-1まで行います。これにより、二番目に大きいものを一番右から２つ目にもっていけます。
- 以上を繰り返します。
- 例： [5, 1, 4, 2, 8]のとき（この例は[wikipedia](https：//en.wikipedia.org/wiki/Bubble＿sort)に載っています）
    - 最初のパス
        - [ (5, 1), 4, 2, 8 ] -> [ (1, 5), 4, 2, 8 ]  // 1と5を比較。5のほうが大きいのでスワップ
        - [ 1, (5, 4), 2, 8 ] -> [ 1, (4, 5), 2, 8 ]  // 5と4を比較。5のほうが大きいのでスワップ
        - [ 1, 4, (5, 2), 8 ] -> [ 1, 4, (2, 5), 8 ]  // 2と5を比較。5のほうが大きいのでスワップ
        - [ 1, 4, 2, (5, 8) ] -> [ 1, 4, 2, (5, 8) ]  // 5と8を比較。8のほうが大きいので何もしない
        - 上記手続きで、最も大きい「8」が一番右に来ました。
    - 二回目のパス
        - [ (1, 4), 2, 5, 8 ] -> [ (1, 4), 2, 5, 8 ]  // 1と4を比較。4のほうが大きいので何もしない
        - [ 1, (4, 2), 5, 8 ] -> [ 1, (2, 4), 5, 8 ]  // 4と2を比較。4のほうが大きいのでスワップ
        - [ 1, 2, (4, 5), 8 ] -> [ 1, 2, (4, 5), 8 ]  // 4と5を比較。5のほうが大きいので何もしない
        - 一番右は一番大きい値だとわかっているので、ここで終了です。
        - これで、二番目に大きい「5」が右から二番目にきました。
    - 三回目のパス
        - [ (1, 2), 4, 5, 8 ] -> [ (1, 2), 4, 5, 8 ]  // 1と2を比較。2のほうが大きいので何もしない
        - [ 1, (2, 4), 5, 8 ] -> [ 1, (2, 4), 5, 8 ]  // 2と4を比較。4のほうが大きいので何もしない
        - これで、三番目に大きい「4」は右から三番目にきました
    - 四回目のパス
        - [ (1, 2), 4, 5, 8 ] -> [ (1, 2), 4, 5, 8 ]  // 1と2を比較。2のほうが大きいので何もしない
        - これで、四番目に大きい「2」は右から四番目にきました
        - これで終わりです。配列はソートされました。

    


## 宿題2: 引数の文字列集合のソート
- `main2.c`を改造し、引数の文字列の文字列長でソートを行うプログラムを書いてください。
- 引数として、文字列（文字数は一個以上）が一個以上与えられます。
- それらを「文字列長」で昇順に並び替えて、スペース１つを挟んで出力してください。
- 文字列長が同数のときは、順番を維持してください。つまり、`./main1 ab de`のときは、`de ab`ではなく`ab de`を返してください。
- ヒント：`include <string.h>`をすると使える`strlen`関数を使うと、文字列の文字数が取得できます。



### 実行コマンドと想定出力
```bash
$ gcc main2.c -o main2
$ ./main1 abc de fghi
de abc fghi
$ ./main1.c horse dog cat 
dog cat horse
$ ./main1 a xxx a xxx
a a xxx xxx 
```


## 宿題3: 正方行列の入力
- `main3.c`を改造し、引数からの入力を正方行列として受け付けるプログラムを書いてください。
- 最初の引数は行列の一辺の長さで、その次からは行列の要素が入ります。
- 小数は`%.2f`で小数点以下二桁まで表示してください。以下、宿題３・４・５において小数を表示するときは常にそうしてください。

### 実行コマンドと想定出力
```bash
$ gcc main3.c -o main3
$ ./main3 2 1.0 2.0 3.0 4.0
1.00 2.00
3.00 4.00
```

## 宿題4: 行列の操作
- `main4.c`を改造し、引数からの入力の正方行列に対し様々な行列操作を行うプログラムを書いてください。
- `main3.c`の中身を流用してOKです。

### 実行コマンドと想定出力
```bash
$ gcc main4.c -o main4
$ ./main4 3 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
check dot:
8.00 
17.00 
26.00 
check copy:
8.00 
17.00 
26.00 
check transpose:
8.00 17.00 26.00 
```


## 発展課題: べき乗法
- `main5.c`を改造し、[べき乗法](https://ja.wikipedia.org/wiki/%E3%81%B9%E3%81%8D%E4%B9%97%E6%B3%95)を実行するコードを書いてください。
- `main4.c`の中身を流用してOKです。
- べき乗法とは、行列Aの固有値のうち絶対値が最大になるものを求める方法です（詳しくは[解説資料](power_iteration.pdf)をどうぞ）
- ランダムなベクトルxを用意し、これに左からAをk回乗じたものをy_kとします。すなわち以下です： 
    - <img src="https://latex.codecogs.com/gif.latex?\mathbf{y}_k&space;=&space;\mathbf{A}^k&space;\mathbf{x}" title="\mathbf{y}_k = \mathbf{A}^k \mathbf{x}" />
- kが十分大きいとき、Aの固有値のうち絶対値最大のものは次の式で近似されることが知られています。
    - <img src="https://latex.codecogs.com/gif.latex?\lambda_\mathrm{max}&space;=&space;\frac{\mathbf{y}_k^\top&space;\mathbf{y}_k}{\mathbf{y}_k^\top\mathbf{y}_{k-1}}" title="\lambda_\mathrm{max} = \frac{\mathbf{y}_k^\top \mathbf{y}_k}{\mathbf{y}_k^\top\mathbf{y}_{k-1}}" />
- この値を表示してください。

### 実行コマンドと想定出力
```bash
$ gcc main5.c -o main5
$ ./main4 2 1.0 2.0 3.0 5.0
6.16
```
これは、理論値は3 + sqrt(10)です（計算してみましょう）。それは約6.162になります。
